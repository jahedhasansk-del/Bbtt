<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>WIN GO 1M - AI PREDICTION</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');
  
  * {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
  }
  
  body {
    font-family: 'Orbitron', monospace;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
    min-height: 100vh;
    padding: 20px;
    position: relative;
    overflow-x: hidden;
  }
  
  /* Animated Background */
  body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: 
      radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
      radial-gradient(circle at 80% 80%, rgba(255, 135, 135, 0.3) 0%, transparent 50%),
      radial-gradient(circle at 40% 20%, rgba(138, 80, 255, 0.3) 0%, transparent 50%);
    animation: gradient-shift 15s ease infinite;
    z-index: 0;
  }
  
  @keyframes gradient-shift {
    0%, 100% { opacity: 0.5; }
    50% { opacity: 0.8; }
  }
  
  .container {
    position: relative;
    z-index: 1;
    max-width: 1400px;
    margin: 0 auto;
  }
  
  /* Prediction Panel - TOP */
  .prediction-panel {
    background: linear-gradient(135deg, rgba(255, 0, 0, 0.9), rgba(255, 100, 100, 0.8));
    border: 3px solid #000;
    border-radius: 15px;
    padding: 30px;
    margin-bottom: 20px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
    animation: glow-pulse 3s infinite;
  }
  
  @keyframes glow-pulse {
    0%, 100% {
      box-shadow: 0 10px 40px rgba(255, 0, 0, 0.5);
    }
    50% {
      box-shadow: 0 10px 60px rgba(255, 0, 0, 0.8);
    }
  }
  
  .prediction-header {
    text-align: center;
    margin-bottom: 25px;
  }
  
  .prediction-title {
    font-size: 2em;
    font-weight: 900;
    color: #fff;
    text-transform: uppercase;
    letter-spacing: 3px;
    text-shadow: 0 0 20px rgba(255, 255, 255, 0.8);
    animation: flicker 2s infinite;
  }
  
  @keyframes flicker {
    0%, 100% { opacity: 1; }
    50% { opacity: 0.8; }
  }
  
  .prediction-subtitle {
    font-size: 0.9em;
    color: #ffeb3b;
    margin-top: 10px;
    letter-spacing: 2px;
  }
  
  .prediction-display {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 30px;
    flex-wrap: wrap;
  }
  
  .prediction-box {
    background: rgba(0, 0, 0, 0.7);
    border: 3px solid #ffeb3b;
    border-radius: 10px;
    padding: 20px 40px;
    min-width: 200px;
    text-align: center;
    animation: bounce 2s infinite;
  }
  
  @keyframes bounce {
    0%, 100% { transform: translateY(0); }
    50% { transform: translateY(-10px); }
  }
  
  .prediction-label {
    font-size: 0.8em;
    color: #ffeb3b;
    margin-bottom: 10px;
    letter-spacing: 2px;
  }
  
  .prediction-value {
    font-size: 3em;
    font-weight: 900;
    color: #fff;
    text-shadow: 0 0 30px #ffeb3b;
    animation: pulse-glow 1.5s infinite;
  }
  
  @keyframes pulse-glow {
    0%, 100% {
      text-shadow: 0 0 20px #ffeb3b;
    }
    50% {
      text-shadow: 0 0 40px #ffeb3b, 0 0 60px #ffeb3b;
    }
  }
  
  .prediction-confidence {
    margin-top: 15px;
    font-size: 0.9em;
    color: #4caf50;
    font-weight: bold;
  }
  
  /* Status Bar */
  .status-bar {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-bottom: 20px;
    flex-wrap: wrap;
  }
  
  .status-item {
    background: rgba(0, 0, 0, 0.7);
    border: 2px solid #ffeb3b;
    border-radius: 10px;
    padding: 10px 20px;
    color: #fff;
    font-weight: bold;
  }
  
  .status-online {
    color: #4caf50;
  }
  
  .status-offline {
    color: #f44336;
  }
  
  /* History Section */
  .history-section {
    background: rgba(0, 0, 0, 0.8);
    border: 3px solid #000;
    border-radius: 15px;
    padding: 20px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.5);
  }
  
  .history-header {
    background: linear-gradient(90deg, #ff0000, #ff6b6b);
    color: #fff;
    padding: 15px;
    border-radius: 10px 10px 0 0;
    display: grid;
    grid-template-columns: 2fr 1fr 1fr 1fr;
    gap: 10px;
    font-weight: 900;
    font-size: 1.1em;
    text-align: center;
    border-bottom: 3px solid #000;
  }
  
  .history-row {
    background: linear-gradient(90deg, rgba(255, 107, 107, 0.3), rgba(255, 159, 107, 0.3));
    border-bottom: 2px solid rgba(0, 0, 0, 0.3);
    padding: 15px;
    display: grid;
    grid-template-columns: 2fr 1fr 1fr 1fr;
    gap: 10px;
    align-items: center;
    text-align: center;
    animation: slideIn 0.5s ease-out;
    transition: all 0.3s ease;
  }
  
  @keyframes slideIn {
    from {
      opacity: 0;
      transform: translateX(-50px);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }
  
  .history-row:hover {
    background: linear-gradient(90deg, rgba(255, 107, 107, 0.5), rgba(255, 159, 107, 0.5));
    transform: scale(1.02);
  }
  
  .cell {
    font-size: 1.1em;
    color: #fff;
    font-weight: bold;
  }
  
  .cell-period {
    font-size: 0.95em;
  }
  
  .cell-number {
    font-size: 1.5em;
    color: #ffeb3b;
    text-shadow: 0 0 10px #ffeb3b;
  }
  
  .result-win {
    color: #4caf50;
    font-weight: 900;
    text-shadow: 0 0 15px #4caf50;
    font-size: 1.2em;
  }
  
  .result-loss {
    color: #f44336;
    font-weight: 900;
    text-shadow: 0 0 15px #f44336;
    font-size: 1.2em;
  }
  
  /* Loading */
  .loading {
    text-align: center;
    padding: 40px;
    color: #fff;
    font-size: 1.2em;
  }
  
  .spinner {
    width: 50px;
    height: 50px;
    border: 4px solid rgba(255, 255, 255, 0.3);
    border-top: 4px solid #fff;
    border-radius: 50%;
    animation: spin 1s linear infinite;
    margin: 0 auto 20px;
  }
  
  @keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }
  
  /* Error Panel */
  .error-panel {
    background: rgba(50, 0, 0, 0.9);
    border: 2px solid #ff0000;
    border-radius: 10px;
    padding: 20px;
    margin-bottom: 20px;
    text-align: center;
  }
  
  .error-text {
    color: #ff0000;
    font-size: 1.1em;
    margin-bottom: 15px;
  }
  
  .retry-button {
    background: #4caf50;
    color: #fff;
    border: none;
    padding: 12px 30px;
    font-family: 'Orbitron', monospace;
    font-size: 1em;
    font-weight: bold;
    cursor: pointer;
    border-radius: 8px;
    transition: all 0.3s ease;
  }
  
  .retry-button:hover {
    background: #45a049;
    transform: scale(1.05);
  }
  
  /* Responsive */
  @media (max-width: 768px) {
    .prediction-title {
      font-size: 1.5em;
    }
    
    .prediction-value {
      font-size: 2em;
    }
    
    .history-header,
    .history-row {
      grid-template-columns: 1fr;
      gap: 5px;
    }
  }
</style>
</head>
<body>
  <div class="container">
    <!-- AI Prediction Panel -->
    <div class="prediction-panel">
      <div class="prediction-header">
        <div class="prediction-title">🎯 AI PREDICTION SYSTEM</div>
        <div class="prediction-subtitle">[ NEXT ROUND FORECAST ]</div>
      </div>
      
      <div class="prediction-display">
        <div class="prediction-box">
          <div class="prediction-label">PREDICTED</div>
          <div class="prediction-value" id="predictedValue">---</div>
          <div class="prediction-confidence" id="confidence">Analyzing...</div>
        </div>
      </div>
    </div>
    
    <!-- Status Bar -->
    <div class="status-bar">
      <div class="status-item">
        Status: <span id="status">Loading...</span>
      </div>
      <div class="status-item">
        Updates: <span id="updateCount">0</span>
      </div>
      <div class="status-item">
        Next: <span id="countdown">--:--</span>
      </div>
    </div>
    
    <!-- Error Panel -->
    <div id="errorPanel"></div>
    
    <!-- History Section -->
    <div class="history-section">
      <div class="history-header">
        <div>PERIOD</div>
        <div>NUMBER</div>
        <div>SIZE</div>
        <div>RESULT</div>
      </div>
      
      <div id="historyGrid">
        <div class="loading">
          <div class="spinner"></div>
          <div>LOADING HISTORY...</div>
        </div>
      </div>
    </div>
  </div>

  <script>
    let updateCount = 0;
    let historyData = [];
    let currentPrediction = null;
    let countdownInterval = null;
    
    // Pattern Rules
    const patternRules = {
      big: {
        counts: [1, 3, 4, 5, 7],
        prediction: 'SMALL'
      },
      small: {
        counts: [2, 4, 5, 9],
        prediction: 'BIG'
      }
    };
    
    const numberPatterns = {
      small: [
        {prev: 4, next: 5}, {prev: 6, next: 1}, {prev: 6, next: 3},
        {prev: 6, next: 5}, {prev: 6, next: 6}, {prev: 0, next: 1},
        {prev: 2, next: 2}, {prev: 1, next: 8}, {prev: 6, next: 4},
        {prev: 0, next: 2}, {prev: 7, next: null}, {prev: 9, next: null}
      ],
      big: [
        {prev: 1, next: 4}, {prev: 4, next: 2}, {prev: 4, next: 3},
        {prev: 4, next: 4}, {prev: 4, next: 7}, {prev: 0, next: 0},
        {prev: 1, next: 2}, {prev: 6, next: 9}, {prev: 1, next: 5},
        {prev: 7, next: 3}, {prev: 3, next: null}, {prev: 4, next: null},
        {prev: 1, next: null}, {prev: 8, next: null}, {prev: 6, next: null}
      ]
    };
    
    function analyzePattern(history) {
      if (history.length < 2) return null;
      
      // Count consecutive Big/Small
      let bigCount = 0;
      let smallCount = 0;
      
      for (let i = 0; i < Math.min(10, history.length); i++) {
        const size = history[i].bigSmall.toLowerCase();
        
        if (size === 'big') {
          bigCount++;
          smallCount = 0;
        } else {
          smallCount++;
          bigCount = 0;
        }
        
        // Check pattern rules
        if (patternRules.big.counts.includes(bigCount)) {
          return {prediction: 'SMALL', confidence: 'Pattern: ' + bigCount + ' BIG in a row'};
        }
        if (patternRules.small.counts.includes(smallCount)) {
          return {prediction: 'BIG', confidence: 'Pattern: ' + smallCount + ' SMALL in a row'};
        }
      }
      
      // Check number patterns
      const lastNum = parseInt(history[0].number);
      const secondLastNum = history[1] ? parseInt(history[1].number) : null;
      
      // Check SMALL patterns
      for (let pattern of numberPatterns.small) {
        if (pattern.prev === lastNum && (pattern.next === null || pattern.next === secondLastNum)) {
          return {prediction: 'SMALL', confidence: 'Number Pattern: ' + lastNum + (secondLastNum !== null ? '→' + secondLastNum : '')};
        }
      }
      
      // Check BIG patterns
      for (let pattern of numberPatterns.big) {
        if (pattern.prev === lastNum && (pattern.next === null || pattern.next === secondLastNum)) {
          return {prediction: 'BIG', confidence: 'Number Pattern: ' + lastNum + (secondLastNum !== null ? '→' + secondLastNum : '')};
        }
      }
      
      return {prediction: 'WAIT', confidence: 'No Clear Pattern Detected'};
    }
    
    function updatePrediction(history) {
      const result = analyzePattern(history);
      
      if (result) {
        currentPrediction = result.prediction;
        document.getElementById('predictedValue').textContent = result.prediction;
        document.getElementById('confidence').textContent = '✓ ' + result.confidence;
      } else {
        currentPrediction = 'WAIT';
        document.getElementById('predictedValue').textContent = 'WAIT';
        document.getElementById('confidence').textContent = 'Insufficient Data';
      }
    }
    
    function checkResult(actual, predicted) {
      if (!predicted || predicted === 'WAIT') return '⏳ WAIT';
      return actual.toUpperCase() === predicted ? '✓ WIN' : '✗ LOSS';
    }
    
    function updateCountdown() {
      const now = new Date();
      const nextMinute = new Date(now);
      nextMinute.setMinutes(nextMinute.getMinutes() + 1);
      nextMinute.setSeconds(2);
      nextMinute.setMilliseconds(0);
      
      const diff = nextMinute - now;
      const remainSeconds = Math.floor(diff / 1000);
      const mins = Math.floor(remainSeconds / 60);
      const secs = remainSeconds % 60;
      
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }
    
    function startCountdown() {
      if (countdownInterval) clearInterval(countdownInterval);
      countdownInterval = setInterval(() => {
        document.getElementById('countdown').textContent = updateCountdown();
      }, 1000);
    }
    
    async function fetchData(isRetry = false) {
      try {
        updateCount++;
        document.getElementById('updateCount').textContent = updateCount;
        
        const ts = new Date().getTime();
        const originalUrl = `https://draw.ar-lottery01.com/WinGo/WinGo_1M/GetHistoryIssuePage.json?ts=${ts}`;
        
        const endpoints = [
          originalUrl,
          `https://api.allorigins.win/raw?url=${encodeURIComponent(originalUrl)}`,
          `https://corsproxy.io/?${encodeURIComponent(originalUrl)}`
        ];
        
        let res = null;
        let lastError = null;
        
        for (const endpoint of endpoints) {
          try {
            res = await Promise.race([
              fetch(endpoint),
              new Promise((_, reject) => 
                setTimeout(() => reject(new Error('TIMEOUT')), 10000)
              )
            ]);
            if (res.ok) break;
          } catch (err) {
            lastError = err;
            continue;
          }
        }
        
        if (!res || !res.ok) {
          throw lastError || new Error('CONNECTION FAILED');
        }
        
        const json = await res.json();
        const list = json.data.list.slice(0, 10);
        
        historyData = list;
        
        // Update prediction
        updatePrediction(list);
        
        const grid = document.getElementById('historyGrid');
        const errorPanel = document.getElementById('errorPanel');
        
        grid.innerHTML = '';
        errorPanel.innerHTML = '';
        
        list.forEach((item, index) => {
          const row = document.createElement('div');
          row.className = 'history-row';
          row.style.animationDelay = `${index * 0.1}s`;
          
          const result = index > 0 ? checkResult(item.bigSmall, currentPrediction) : '---';
          const resultClass = result.includes('WIN') ? 'result-win' : result.includes('LOSS') ? 'result-loss' : '';
          
          row.innerHTML = `
            <div class="cell cell-period">${item.issueNumber || item.issue}</div>
            <div class="cell cell-number">${item.number}</div>
            <div class="cell">${item.bigSmall.toUpperCase()}</div>
            <div class="cell ${resultClass}">${result}</div>
          `;
          
          grid.appendChild(row);
        });
        
        document.getElementById('status').textContent = '● ONLINE';
        document.getElementById('status').className = 'status-online';
        
      } catch (e) {
        console.error('ERROR:', e);
        
        const errorPanel = document.getElementById('errorPanel');
        errorPanel.innerHTML = `
          <div class="error-panel">
            <div class="error-text">⚠ CONNECTION ERROR: ${e.message}</div>
            <button class="retry-button" onclick="fetchData(true)">RETRY NOW</button>
          </div>
        `;
        
        document.getElementById('status').textContent = '● OFFLINE';
        document.getElementById('status').className = 'status-offline';
        
        if (!isRetry) {
          setTimeout(() => fetchData(true), 10000);
        }
      }
    }
    
    // Initialize
    fetchData();
    startCountdown();
    
    function scheduleNextUpdate() {
      const now = new Date();
      const nextMinute = new Date(
        now.getFullYear(),
        now.getMonth(),
        now.getDate(),
        now.getHours(),
        now.getMinutes() + 1,
        2,
        0
      );
      const delay = nextMinute - now;
      
      setTimeout(() => {
        fetchData();
        scheduleNextUpdate();
      }, delay);
    }
    
    scheduleNextUpdate();
    
    // Network monitoring
    window.addEventListener('online', () => fetchData(true));
    window.addEventListener('offline', () => {
      document.getElementById('status').textContent = '● OFFLINE';
      document.getElementById('status').className = 'status-offline';
    });
  </script>
</body>
</html>
